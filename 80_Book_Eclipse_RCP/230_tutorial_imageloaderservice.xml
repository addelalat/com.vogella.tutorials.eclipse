<chapter id="tutorial_imageloader">
== Optional exercise: Create an image loader service

=== Target of this exercise
		In this exercise you create a service for your application which
			allows you to load
			images. We use the same
			plug-in (bundle) for
			the
			interface
			definition and the service definition. This is a valid setup
			if you
			plan to have only
			one service implementation.
		
	

=== Creating a new plug-in
		
			Create a new simple plug-in called
			_com.example.e4.bundleresourceloader_
			.
		
		
			Add the following plug-ins as dependencies to your new plug-in.

			<itemizedlist>
				<listitem>
					
						`org.eclipse.core.runtime`
					
				</listitem>
				<listitem>
					
						`org.eclipse.jface`
					
				</listitem>
				<listitem>
					
						`org.eclipse.osgi.services`
					
				</listitem>
			</itemizedlist>
		

		<note>
			
				The
				`org.eclipse.jface`
				plug-in re-exports the
				`org.eclipse.swt`
				hence if you define a dependency to *.jface you can also use the
				classes from *.swt.
			
		</note>
	

=== Ensure that OSGi DS service functionality is available
		
			Ensure that the plug-in is activated and that OSGi DS annotation processing is active.
			similar to
			<xref linkend="tutorial_e4services_enable_ds_annotations" />
			.
		

	

=== Creating the service interface
		
			Create
			the following interface called
			`IBundleResourceLoader`
			.
		

		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"
					href="./examples/service/IBundleResourceLoader.java" />
			</programlisting>
		


	

=== Creating a service implementation

		
			Create the following class which allows, via its
			`getImageDescriptor()`
			method, to
			load an ImageDescriptor from a plug-in based on the class
			provided as
			parameter.
		

		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"
					href="./examples/service/BundleResourceLoaderImpl.java" />
			</programlisting>
		


	


=== Adding the new plug-in to your feature project
		Add the new plug-in to your product
			configuration
			file via your
			feature project.
		
	

=== Exporting the API
		
			To use the service in other plug-ins, export the package which
			contains the
			interface in the
			corresponding
			_MANIFEST.MF_
			file.
		
	

=== Adding the dependencies to the new plug-in
		
			Define a dependency to
			the new
			package (or the whole
			plug-in) in the
			_MANIFEST.MF_
			file of your application plug-in.
		
		
			Also add a dependency to
			`org.eclipse.jface`
			to your application manifest.
		

	

=== Using the new service
		
			Create a directory called
			_images_
			in your application plug-in
			and put an image with the file name
			_vogella.png_
			into it. A Google search for
			_vogella.png_
			should find such an image, but you can use any *.png file you like.
		
		
			Use the image loader service in your
			`PlaygroundPart`
			class.
			The following code demonstrates the usage of
			your service based on the path name from above.
			See
			<xref linkend="swt_overview" />
			and
			<xref linkend="jface_localresoucemanager" />
			to learn more about the code snippet.
		
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/service/LabelAssign.java" />
			</programlisting>
		


		The result might look like the following.

		
image::imageservice.png[Image on Label,pdfwidth=60%]
		
		<warning>
			As you added plug-ins to your product via the feature,
				remember
				to start via the product configuration file.
				Using the existing run
				configuration does not work.
			
		</warning>
	

=== Reviewing the implementation
		
			In this example the service interface and the
			implementation
			class is contained in one plug-in. Therefore, this
			plug-in needs to
			export the interface and consuming plug-ins must define a
			dependency
			to this service plug-in. In the
			first service we separated the
			implementation and the service interface as this allows you to
			replace the service
			easily.
		
		
			Both approaches are valid. You typically put the interface and
			the implementation in one plug-in, if you do not
			expect an
			alternative
			implementation of the service interface.
		

	
</chapter>
