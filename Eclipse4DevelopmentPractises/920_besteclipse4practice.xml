<section id="bestpractices" role="wrapper">
	<title>Eclipse development good practices</title>
	<indexterm>
		<primary>Development practices</primary>
	</indexterm>

	<section id="bestpractices_packagename">
		<title>Project, package and class names</title>
		<indexterm>
			<primary>Naming conventions</primary>
			<secondary>Projects</secondary>
		</indexterm>
		<indexterm>
			<primary>Naming conventions</primary>
			<secondary>Packages and classes</secondary>
		</indexterm>
		<para>
			It is good practice to use your reverse web domain
			name as top-level
			package identifier. For example if you own the
			domain
			<wordasword>mycompany.com</wordasword>
			you package name space would start with
			<code>com.mycompany</code>
			. This avoids name collision with packages contributed by other
			plug-ins.
		</para>

		<para>The following table suggests good practices for naming
			conventions for projects, packages and classes.
		</para>
		<table frame="all">
			<title>Naming conventions</title>
			<tgroup align="left" cols="2" colsep="1" rowsep="1">
				<colspec colname="c1" colwidth="1*" />
				<colspec colname="c2" colwidth="3*" />
				<thead>
					<row>
						<entry>Object</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Project Names</entry>
						<entry> The plug-in
							project name is the same as the top-level
							package
							name.
						</entry>
					</row>
					<row>
						<entry>Packages</entry>
						<entry>
							Plug-ins which contain a lot of user interface components use
							sub-packages based on the primary purpose of the
							components. For
							example,
							the
							<code>com.example</code>
							package
							may have the
							<code>com.example.parts</code>
							and
							<code>com.example.handler</code>
							sub-package.
						</entry>
					</row>

					<row>
						<entry>Class names for model elements</entry>
						<entry>
							Use the primary purpose of the model element as a suffix in the
							class
							name. For example, a class used as a part
							implementation,
							should be called
							<code>[PurposeDescription]Part</code>
							.
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</section>

	<section id="e4modelids_requirements">
		<title>Naming conventions for model identifiers (IDs)</title>
		<indexterm>
			<primary>Naming conventions</primary>
			<secondary>ID for model elements</secondary>
		</indexterm>
		<para>
			Every model element allows you to define an ID. This ID is used
			by
			the Eclipse framework to identify this model
			element. Make sure you
			always maintain an ID for every model element and ensure that these
			IDs are unique whenever it
			makes sense. Reusing IDs is sometimes
			required. For example you typically use the same ID for the main menu
			in every
			window of you application. This allows menu contributions to
			contribute to every window its menu entries.
		</para>
		<para>
			Unintentionally using the same ID for a model element may result
			in unexpected behavior. For example if you
			search for a element via
			the ID.
		</para>

		<para>
			A good convention is to start IDs with the
			<wordasword>top level package</wordasword>
			name of
			your project followed by a group descriptor and a name which
			gives an
			idea about the purpose of the element. For
			example,
			<wordasword>com.example.e4.rcp.todo.part.todooverview</wordasword>
			, where
			<wordasword>com.example.e4.rcp.todo</wordasword>
			is the top level
			package,
			<wordasword>part</wordasword>
			is the group
			descriptor for all visible
			parts (views and editors)
			in
			your
			application and
			<wordasword>todooverview</wordasword>
			gives an
			idea about the purpose of this
			part.
		</para>
		<para>
			Also note that the
			entire
			ID is
			written only in lower case
			characters.
		</para>

		<para>Some
			Eclipse projects also
			use
			camelCase for the last part of the
			ID, but that is
			more for historical reasons.
		</para>

	</section>

	<section id="bestpractices_components">
		<title>Create isolated components</title>
		<para>
			It is important to separate your application components into
			isolated
			modules. This reduces the complexity of
			development and
			allows you to reuse these components in different
			applications.
		</para>
		<para>
			User interface
			related and core functionalities
			should be
			separated
			into
			different
			plug-ins. For example, if you
			develop a new SWT
			widget, you should place this widget in a separate plug-in.
		</para>
		<para>
			The
			data model
			of the application should be kept in its own
			plug-in. Almost all
			plug-ins
			will depend on this plug-in,
			therefore
			keep it as small as
			possible.
		</para>
	</section>



	<section id="bestpracticese_extensionpoints">
		<title>Usage of your custom extension points</title>
		<para>
			The programming model of Eclipse 4 has reduced the need for
			using extensions and extension points but they still
			have
			valid use
			cases.
		</para>
		<para>
			If you
			have multiple
			plug-ins which should contribute to a defined
			API,
			you
			can still define and use
			your own
			extension
			points.
		</para>
	</section>


	<section id="bestpractices_minimizeapi">
		<title>Avoid releasing unnecessary API</title>
		<para>
			Eclipse plug-ins explicitly declare their API via their exported
			packages. Publish only the packages which other
			plug-ins should use.
			This
			way you can later on change your internal API without affecting
			other plug-ins.
			Avoid
			exporting
			packages just for testing.
		</para>
	</section>

	<section id="bestpractices_dependencies">
		<title>Packages vs. plug-in dependencies</title>
		<para>OSGi allows you to define dependencies via plug-ins (Require-Bundle) or via packages (Import-Package) in the
			manifest file.
		</para>
		<para>
			Dependencies based on packages express an API dependency as
			they
			allow you to
			exchange the implementing plug-in.
			Dependencies based on
			plug-ins imply a dependency on
			an implementation.
		</para>
		<para>
			Use package
			dependencies
			whenever
			you intend to
			exchange the
			implementing
			plug-in.
		</para>
		<para>
			Package dependencies add complexity to the setup as you usually
			have
			more packages than plug-ins.
		</para>
		<para>
			Therefore
			use plug-in
			dependencies,
			if
			there is only one
			implementing
			plug-in and
			an
			exchange of this
			plug-in in
			the near
			future is
			unlikely.
		</para>
	</section>

</section>