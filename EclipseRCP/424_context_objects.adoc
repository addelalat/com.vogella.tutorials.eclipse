== Objects available for dependency injection


=== How are objects selected for dependency injection

As described in <xref linkend="dependencyinjection_eclipse" /> an object which is created by Eclipse can use annotations to describe its class dependencies.

During dependency injection for an object created by Eclipse, the Eclipse framework searches for a fitting object based on the specified key.
The search starts in the local context associated with the application model object.
If this key is not available, Eclipse continues to search in the parent context.
This process continues until the main context has been reached.

image::contexthierarchy10.png[Context hierarchy with OSGi,pdfwidth=60%]

As you learn in later chapters the Eclipse context is not the only possible source of objects which can get injected.
Other examples which are covered later are OSGi services, preferences, events and
custom objects.
The search happens (mostly) transparently for the caller of the injection.

=== How to access the model objects?

For the class references in the application model (see <xref linkend="connectmodeltojava" /> ), the Eclipse framework creates the corresponding objects when needed.
Such an object has access to its corresponding model object (see <xref linkend="importantmodelelement_element" />) via dependency injection.

For example, in the implementation of a part you can access the model information of a part via: `@Inject MPart part;`

=== Default entries in the Eclipse context

The Eclipse framework creates several objects in the context.
These are:

* model objects - contain the data of the application model
* services - software components which are defined by the Eclipse platform or via the OSGi service registry
* several other objects which have explicitly been added to the context

The context can be modified by the application code and the framework.
As the Eclipse framework automatically tracks the dependencies of the objects it creates, it can update them as described in <xref linkend="dependencyinjection_reinject" />.

=== Qualifiers for accessing the active part or shell

(((IServiceConstants, ACTIVE_SHELL)))
(((IServiceConstants, ACTIVE_PART)))

The Eclipse platform places the part which is currently selected and the active shell into the `IEclipseContext` of the application object. The related keys are defined in the `IServiceConstants` interface.

For example, the following method would allow you to track the current active part in another part.

[source,java]
----
include::res/active/receiveActivePart.java[]
----

To track the active shell use the `IServiceConstants.ACTIVE_SHELL` key.

[source,java]
----
include::res/active/receiveActiveShell.java[]
----

NOTE:Eclipse uses handlers to define actions which can be triggered via menu or toolbar entries.
For a handler implementation class it is not necessary to use these qualifiers, as a handler is executed in the active context of the application.

=== Tracking a child context with @Active

The `@Active` annotation allows you to track values in a child context.
The Eclipse framework keeps track of the current active branch in the hierarchy of the `IEclipseContext`.
For example, if the user selects a part, the path in the `IEclipseContext` hierarchy from the root to the `IEclipseContext` of the part is the current active branch.

With the `@Active` annotation you can track values in the current active branch of a child element.
Whenever the active branch changes and the value of the referred key changes this value is re-injected into the object which uses the `@Active` annotation.

The usage of this annotation is demonstrated by the followingcode snippet.

[source,java]
----
include::res/active/MyOwnClass.java[]
----

NOTE:The `@Active` annotation is currently not used within the Eclipse framework itself and the author of this $book has not yet managed to find a good use case for this annotation.

