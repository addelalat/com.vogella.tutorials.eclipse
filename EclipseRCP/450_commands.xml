<section id="commands" role="wrapper">
	<title>Menu and toolbar application objects</title>

	<section id="commands_menu">
		<title>Adding menu and toolbar entries</title>
		<indexterm>
			<primary>Menu</primary>
		</indexterm>

		<indexterm>
			<primary>Toolbar</primary>
		</indexterm>

		<indexterm>
			<primary>Direct MenuItem</primary>
		</indexterm>

		<indexterm>
			<primary>Direct ToolItem</primary>
		</indexterm>

		<indexterm>
			<primary>Handled MenuItem</primary>
		</indexterm>

		<indexterm>
			<primary>Handled ToolItem</primary>
		</indexterm>
		<para>
			You can add menus and toolbars to your RCP application via the
			application
			model. These entries can be positioned
			at
			various places.
			You can, for example, add a menu to a window or a part. These elements
			define, directly or indirectly,
			a link to a class.
			An instance of this class is created by the framework and responsible for the behavior if the menu
			or toolbar entry is
			selected.
			Such a class is called
			<wordasword>handler class</wordasword>
			.
		</para>
	</section>
	<section id="commands_overview">
		<title>The usage of commands and handlers</title>
		<indexterm>
			<primary>Command</primary>
		</indexterm>
		<indexterm>
			<primary>Commands</primary>
		</indexterm>
		<indexterm>
			<primary>Handler</primary>
		</indexterm>
		<indexterm>
			<primary>Handlers</primary>
		</indexterm>
		<para>
			The Eclipse application model allows you to specify
			<wordasword>commands</wordasword>
			and
			<wordasword>handlers</wordasword>
			.
		</para>

		<para>
			The usage of the commands and handlers model element is optional.
			You can use the
			<wordasword>Direct MenuItem</wordasword>
			or
			a
			<wordasword>Direct ToolItem</wordasword>
			model elements. These entries define a reference to a class (handler class). An instance of this handler class is
			created by the
			framework and its annotated methods are called by the framework if necessary. Menus and toolbars
			support separators.
		</para>
		<para>
			A
			command
			is a declarative description of an abstract
			action which
			can be
			performed, for example,
			<wordasword>save</wordasword>
			,
			<wordasword>edit</wordasword>
			or
			<wordasword>copy</wordasword>
			.
			A command is independent from its implementation details. The Eclipse framework does
			not provide standard commands,
			i.e., you have to
			create all required
			commands in your
			application model.
		</para>

		<para>
			The behavior of a
			command
			is defined via a
			handler. A handler model
			element points to
			a
			class (handler class) via the
			<code>contributionURI</code>
			property of the handler. This attribute is displayed as
			<guilabel>Class URI</guilabel>
			in the model editor.
		</para>

		<para>
			Commands are used by the
			<wordasword>Handled MenuItem</wordasword>
			and
			<wordasword>Handled ToolItem</wordasword>
			model elements.
		</para>
		<para>
			Prefer the usage of commands over the usage of direct (menu or
			tool) items.
			Using
			commands together with handlers
			allows you to
			define
			different handlers for different
			scopes
			(applications or part)
			and
			you can
			define key bindings for the
			handler's associated commands.
		</para>
	</section>

	<section id="commands_behaviorannotations">
		<title>Behavior annotations and dependency injection for handler classes</title>
		<indexterm>
			<primary>Behavior annotations</primary>
			<secondary>Handler</secondary>
		</indexterm>
		<indexterm>
			<primary>@Execute</primary>
		</indexterm>
		<indexterm>
			<primary>@CanExecute</primary>
		</indexterm>
		<para>
			In a handler class exactly one
			method must be annotated
			with the
			<code>@Execute</code>
			annotation. In additional, you can also annotate one method with the
			<code>@CanExecute</code>
			annotation. If you annotate more than one method with the same annotation, the framework calls only one of them.
			The
			Eclipse runtime uses dependency injection to provide the
			parameters of the method.
			The purpose of these annotations are
			described in
			the following table.
		</para>

		<para>
			<table frame='all'>
				<title>Behavior annotations for handler classes</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1' colwidth="1.0*" />
					<colspec colname='c2' colwidth="4.0*" />
					<thead>
						<row>
							<entry>Annotation</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>@Execute</entry>
							<entry>
								<para>

									Marks the method which is responsible for the action
									of the
									handler class. The framework executes this
									method
									once
									the
									related
									user interface element, e.g., the menu entry, is
									selected.

								</para>

							</entry>
						</row>
						<row>
							<entry>@CanExecute</entry>
							<entry>
								<para>
									Marks a method to be
									visited by the Eclipse framework to
									check if
									the handler class can be executed. If a handler
									class
									returns
									<code>false</code>
									in this method,
									Eclipse
									disables
									the corresponding user interface
									element. For example, the save
									button is active if
									the handler
									class returns true in the
									<code>@CanExecute</code>
									method.
								</para>
								<para>
									The default for this method is true, which means, if the
									handler
									class can always be executed, it does not need
									to
									implement a
									<code>@CanExecute</code>
									method.
								</para>
							</entry>
						</row>


					</tbody>
				</tgroup>
			</table>
		</para>

		<para>The following example demonstrates the implementation of a
			handler class.
		</para>
		<para>
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/command/Example.java" />
			</programlisting>
		</para>

		<para>
			A handler instance does not have its own Eclipse context (
			<code>IEclipseContext</code>
			).
			It is executed with the
			Eclipse context of the active model element which has a Eclipse context. In most
			common
			cases
			this
			is
			the
			context of
			the
			active part.
		</para>
		<para>
			All required parameters should be injected into the
			method
			annotated
			with
			<code>@Execute</code>
			, as you want the handler class to retrieve its
			runtime
			information
			during execution.
		</para>
		<warning>
			<para>To ensure that you get the expected values from the active
				context
				ALWAYS get the required values injected as
				parameters into your methods annotated with @Execute or @CanExecute.
			</para>
		</warning>

	</section>

	<section id="commands_valid">
		<title>Determining the relevant handler for a command</title>
		<para>If a
			command is
			selected, the runtime determines the
			relevant
			handler
			for the
			command. The
			application model allows you
			to create a
			handler for the
			application,
			a window and a part.


		</para>
		<para>Each command can have only one valid handler for a given scope.
			The Eclipse framework
			selects the
			handler most
			specific to the
			model
			element.
		</para>
		<para> For example, if you have two handlers for the "Copy"
			command,
			one
			for the window and another one for the part then
			the
			runtime
			selects
			the
			handlers closest to model element which is currently
			selected by
			the
			user.
		</para>

	</section>


	<section id="commands_evalationofcanexecute">
		<title>Evaluation of @CanExecute</title>
		<para>
			A method annotated with
			<code>@CanExecute</code>
			is called by the framework, if a change in the Eclipse context happens. For example, if you select a new part.
			If the
			method
			returns
			<code>false</code>
			, the framework
			disables any menu and
			tool
			items that point to that command.
		</para>

		<para>
			You can request the re-evaluation of the
			<code>@CanExecute</code>
			methods by sending out an event via the event broker.
		</para>

		<para>
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"
					href="./examples/canexecutetrigger/triggerevent.java" />
			</programlisting>
		</para>
	</section>




	<section id="commands_accessibility">
		<title>Mnemonics</title>
		<indexterm>
			<primary>Mnemonics</primary>
		</indexterm>
		<para>
			The application model allows you to define
			<wordasword>mnemonics</wordasword>
			.
			A
			mnemonic
			appears as an underlined letter in the menu
			when
			the user
			presses and
			holds the
			<keycombo>
				<keycap>ALT</keycap>
			</keycombo>
			key and allows the user to quickly access menu entries by keyboard.
		</para>
		<para>
			You specify
			mnemonics by prefixing the letter
			intended to be
			the
			mnemonic
			with an ampersand (<![CDATA[&]]>)
			in the label
			definition.
			For example, the
			label
			<![CDATA[&Save]]>
			with the S underlined
			(
			<emphasis role="underline">S</emphasis>
			)
			when the
			<keycombo>
				<keycap>Alt</keycap>
			</keycombo>
			key is pressed.
		</para>
	</section>


	<section id="commands_ids">
		<title>Naming schema for command and handler IDs</title>
		<indexterm>
			<primary>Naming conventions</primary>
			<secondary>Command IDs</secondary>
		</indexterm>
		<indexterm>
			<primary>Naming conventions</primary>
			<secondary>Handler IDs</secondary>
		</indexterm>
		<para>
			A good convention is to start IDs with the
			<wordasword>top level package name</wordasword>
			of your project
			and to use only lower case letters.
		</para>


		<para>
			The IDs of commands and handlers should reflect their
			relationship.
			For
			example, if you implement a
			command with the
			<code>com.example.contacts.commands.show</code>
			ID, you should use
			<code>com.example.contacts.handler.show</code>
			as the ID for the handler. If you have more than one handler for one
			command,
			add
			another suffix to it, describing its
			purpose,
			e.g.
			<code>com.example.contacts.handler.show.details</code>
			.
		</para>
		<para>
			In case you implement commonly used functions, e.g., save, copy,
			you
			should use the existing platform IDs, as some
			Eclipse
			contributions
			expect these IDs to better integrate with the OS (e.g., on Mac OS,
			preferences are normally placed
			under the first menu).
			A more complete list of command IDs
			is available in
			<code>org.eclipse.ui.IWorkbenchCommandConstants</code>
			.
		</para>

		<table frame='all'>
			<title>Default IDs for commonly used commands</title>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
				<colspec colname='c1' colwidth="1*" />
				<colspec colname='c2' colwidth="3*" />
				<thead>
					<row>
						<entry>Command</entry>
						<entry>ID</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Save</entry>
						<entry>org.eclipse.ui.file.save</entry>
					</row>
					<row>
						<entry>Save All</entry>
						<entry>org.eclipse.ui.file.saveAll</entry>
					</row>
					<row>
						<entry>Undo</entry>
						<entry>org.eclipse.ui.edit.undo</entry>
					</row>
					<row>
						<entry>Redo</entry>
						<entry>org.eclipse.ui.edit.redo</entry>
					</row>
					<row>
						<entry>Cut</entry>
						<entry>org.eclipse.ui.edit.cut</entry>
					</row>
					<row>
						<entry>Copy</entry>
						<entry>org.eclipse.ui.edit.copy</entry>
					</row>
					<row>
						<entry>Paste</entry>
						<entry>org.eclipse.ui.edit.paste</entry>
					</row>
					<row>
						<entry>Delete</entry>
						<entry> org.eclipse.ui.edit.delete</entry>
					</row>
					<row>
						<entry>Import</entry>
						<entry>org.eclipse.ui.file.import</entry>
					</row>
					<row>
						<entry>Export</entry>
						<entry>org.eclipse.ui.file.export</entry>
					</row>
					<row>
						<entry>Select All</entry>
						<entry>org.eclipse.ui.edit.selectAll</entry>
					</row>
					<row>
						<entry>About</entry>
						<entry>org.eclipse.ui.help.aboutAction</entry>
					</row>
					<row>
						<entry>Preferences</entry>
						<entry>org.eclipse.ui.window.preferences</entry>
					</row>
					<row>
						<entry>Exit</entry>
						<entry>org.eclipse.ui.file.exit</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

	</section>

</section>