
	<title>OSGi service low-level API
[[osgiapiservice_overview">
=== Using the OSGi service API
		OSGi provides several means of declaring services. This $book focus on the OSGi declarative service
			functionality but it is also possible to use other means for defining services. These options are depicted in the
			following picture. Blueprint and Declarative Services provide high level abstractions for handling services.
		
		
image::osgiserviceoptions.png" scale="30" />
				</imageobject>
				<textobject>
					<phrase>Options for defining OSGi services,pdfwidth=60%]
		


		
			This chapter describes the API to work
			directly with OSGi services but, if you have the option, you should prefer higher
			level
			abstractions as these
			simplify the
			handling
			of OSGi
			services.
		
	
[[osgiservice_bundlecontext">
=== BundleContext
		
			Access to the service registry is performed via the
			<code>BundleContext</code>
			class.
		
		
			A bundle can define a
			<code>Bundle-Activator</code>
			(Activator) in its declaration. This class must implement the
			<code>BundleActivator</code>
			interface.
		
		
			If defined,
			OSGi injects the
			<code>BundleContext</code>
			into the
			<code>start()</code>
			and
			<code>stop()</code>
			methods of the implementing
			<code>Activator</code>
			class.
		
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/context/activator.java" />
			</programlisting>
		
		
			If you do not have an
			<code>Activator</code>
			,
			you can use the
			<code>FrameworkUtil</code>
			class from the OSGi framework which allows you to retrieve the
			<code>BundleContext</code>
			for a
			class.
		
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/context/getBundleContext.java" />
			</programlisting>
		
	

[[osgiservice_register">
=== Registering services via API
		
			A bundle can also register itself for the events
			(
			<code>ServiceEvents</code>
			)
			of the
			<code>BundleContext</code>
			.
			These are, for example, triggered if a new bundle is
			installed or
			de-installed or if a new service is registered.
		

		 To publish a service in your bundle use: 
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/service/register.java" />
			</programlisting>
		

		
			Once the service is no longer used, you must unregister the
			service with OSGi. OSGi counts the usage of services
			to enable the
			dynamic replacement of services. So once the service is no longer
			used by your implementation, you should
			tell the OSGi environment
			this by:
		
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/service/unregisterservice.java" />
			</programlisting>
		

		
			In the
			<code>registerService()</code>
			method from the
			<code>BundleContext</code>
			class you can specify arbitrary properties in the
			dictionary
			parameter.
		
		
			You can
			use the
			<code>getProperty()</code>
			method of the
			<code>ServiceReference</code>
			class from the
			<code>org.osgi.framework</code>
			package,
			to access a specific property.
		
	

[[osgiservice_aquire">
=== Accessing a service via API
		
			A bundle can acquire a service via the
			<code>BundleContext</code>
			class. The following example demonstrates that.
		
		
			<programlisting language="java">
				<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/service/getservice.java" />
			</programlisting>
		
	

[[osgiservice_problems">
=== Low-level API vs OSGi declarative services
		 OSGi services can be dynamically started and stopped. If you
			work with the OSGI low-level API you have to handle
			this dynamic in
			your code. This make the source code unnecessary complex. If you do
			not handle that correctly your
			service consumer can keep a reference
			to
			the
			service and the
			service cannot
			be removed via the OSGi framework.
		
		
			To handle the dynamics automatically declarative services were
			developed.
			Prefer therefore the usage of
			OSGi
			_declarative services_
			over the low-level API.
		
	

